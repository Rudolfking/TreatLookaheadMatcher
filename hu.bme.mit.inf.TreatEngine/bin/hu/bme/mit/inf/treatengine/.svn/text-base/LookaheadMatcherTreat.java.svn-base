package hu.bme.mit.inf.treatengine;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;

import hu.bme.mit.inf.lookaheadmatcher.LookaheadMatcherInterface;
import hu.bme.mit.inf.lookaheadmatcher.impl.AheadStructure;
import hu.bme.mit.inf.lookaheadmatcher.impl.AxisConstraint;
import hu.bme.mit.inf.lookaheadmatcher.impl.FindConstraint;
import hu.bme.mit.inf.lookaheadmatcher.impl.LookVariable;
import hu.bme.mit.inf.lookaheadmatcher.impl.LookaheadMatching;
import hu.bme.mit.inf.lookaheadmatcher.impl.MultiSet;
import hu.bme.mit.inf.lookaheadmatcher.impl.RelationConstraint;
import hu.bme.mit.inf.lookaheadmatcher.impl.TypeConstraint;
//import com.google.common.collect.*;

import org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryEngine;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.Pattern;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.common.notify.Notifier; // kell!
import org.eclipse.viatra2.emf.incquery.base.api.DataTypeListener;
import org.eclipse.viatra2.emf.incquery.base.api.FeatureListener;
import org.eclipse.viatra2.emf.incquery.base.api.InstanceListener;
import org.eclipse.viatra2.emf.incquery.base.api.NavigationHelper;
import org.eclipse.viatra2.emf.incquery.runtime.exception.IncQueryException;

import com.google.common.collect.HashMultimap;

public class LookaheadMatcherTreat
{
	// engine (incquery), matcher(lookahead) and navigationhelper(IQbase)
	private IncQueryEngine engine;
	private LookaheadMatcherInterface matcher;
	private NavigationHelper navHelp;
	
	// rete engine and navigation helper in constructor
	public LookaheadMatcherTreat(IncQueryEngine engineRe)
	{
		matcher = new LookaheadMatcherInterface();
		engine = engineRe;
		DeltaProcessor.getInstance().setEngine(engineRe);
		try
		{
			navHelp = engine.getBaseIndex();
		}
		catch (IncQueryException e)
		{
			e.printStackTrace();
		}
	}
	
	// maps a pattern to a matching (multi set): one pattern, more matches and a specific match can occur more than once (different local variables pl.)
	public static HashMap<Pattern, MultiSet<LookaheadMatching>> GodSet = new HashMap<Pattern, MultiSet<LookaheadMatching>>();
	
	// a pattern and its processed structures
	public static HashMap<Pattern, ArrayList<AheadStructure>> GodSetStructures = new HashMap<Pattern, ArrayList<AheadStructure>>();
	
	// a pattern and its processed structures
	public static HashMap<Pattern, HashMap<Pattern, Boolean>> PatternCallsPatterns = new HashMap<Pattern, HashMap<Pattern, Boolean>>();
	
	// a named element (class, structuralfeature) mapped to the affected patterns
	public static HashMap<ENamedElement, HashSet<Pattern>> RelativeSet = new HashMap<ENamedElement, HashSet<Pattern>>();
	
	// captures an "instance" (eclass) change (insertion, deletion) then copies and modifies the aheadstructures to match insertion/deletion, then runs a patternmatcher, then updates the cached matchings
	private InstanceListener classListener = new InstanceListener()
	{
		@Override
		public void instanceInserted(EClass clazz, EObject instance)
		{
			// InstanceDelta instInsert = new InstanceDelta(clazz, instance, true);
			System.out.println("[ECLASS] Update affected patterns' matchings started!");
			long start = System.currentTimeMillis();
			// changes:
			ArrayList<Delta> deltas = new ArrayList<Delta>();
			
			// check all patterns affected!
			for (Pattern maybeModPattern : RelativeSet.get(clazz))
			{
				// this lookvariable should be ---> this object (the matcher will bind it)
				HashMap<LookVariable, Object> knownLocalAndParameters = new HashMap<LookVariable, Object>();
				
				// get cached pattern structures
				ArrayList<AheadStructure> cachedStructures = GodSetStructures.get(maybeModPattern);
				for (AheadStructure aSn : cachedStructures)
				{
					// find all typeConstraints (eclass affected!)
					for (AxisConstraint tC : aSn.SearchedConstraints)
					{
						if (tC instanceof TypeConstraint)
						{
							if (((TypeConstraint) tC).getType().equals(clazz))
							{
								// affected typeconstraint's lookvariable should be bound!!
								knownLocalAndParameters.put(((TypeConstraint) tC).getLookvariable(), instance);
							}
						}
					}
				}
				
				// the new matches that'll appear in matching
				MultiSet<LookaheadMatching> newbies = matcher.searchChangesAll(engine, maybeModPattern, cachedStructures, knownLocalAndParameters);
				
				// a new map to store a matching and whether it is added or removed
				HashMultimap<LookaheadMatching, Boolean> newMatchingsAndAddition = HashMultimap.create();
				
				// iterate over multiset and create delta
				for (Entry<LookaheadMatching, Integer> inners : newbies.getInnerMap().entrySet())
				{
					for (int pi = 0; pi < inners.getValue(); pi++)
						newMatchingsAndAddition.put(inners.getKey(), true); // the count in multiset (more of tha same found: more changes)
				}
				// delta needed to propagate the changes
				Delta d = new Delta(maybeModPattern, newMatchingsAndAddition);
				deltas.add(d);
				
				// ret
				
				/*
				isModified = false;
				ArrayList<AheadStructure> newStructs = createNewFromOldTypeC(true, clazz, instance, GodSetStructures.get(maybeMod));
				if (isModified)
				{
					MultiSet<LookaheadMatching> newbies = matcher.updateAll(engine, maybeMod, newStructs);
					HashMap<LookaheadMatching, Boolean> newMap = new HashMap<LookaheadMatching, Boolean>();
					if (newbies.size() > 0)
					{
						MultiSet<LookaheadMatching> combinedMatching = GodSet.get(maybeMod);
						for (Entry<LookaheadMatching, Integer> inners : newbies.getInnerMap().entrySet())
						{
							combinedMatching.add(inners.getKey());
							for (int pi = 0; pi < inners.getValue(); pi++)
								newMap.put(inners.getKey(), true); // the count in multiset (more of tha same found: more changes)
						}
						GodSet.put(maybeMod, combinedMatching);
					}
				}
				*/
			}
			// apply deltas (depth apply!)
			for (Delta delta : deltas)
			{
				DeltaProcessor.getInstance().ProcessDelta(delta);
			}
			// match based on the new structs!
			System.out.println("[ECLASS] Update matchings finished! Time:" + Long.toString(System.currentTimeMillis() - start));
		}
		
		@Override
		public void instanceDeleted(EClass clazz, EObject instance)
		{
			// InstanceDelta instRemov = new InstanceDelta(clazz, instance, false);
			System.out.println("[ECLASS] Delete affected patterns' matchings if class instance used in them started!");
			long start = System.currentTimeMillis();
			
			// changes:
			ArrayList<Delta> deltas = new ArrayList<Delta>();
			
			for (Pattern maybeModPattern : RelativeSet.get(clazz))
			{
				// this lookvariable should be ---> this object (the matcher will bind it)
				HashMap<LookVariable, Object> knownLocalAndParameters = new HashMap<LookVariable, Object>();
				
				isModified = false;
				ArrayList<AheadStructure> cachedStructures = GodSetStructures.get(maybeModPattern);
				for (AheadStructure aSn : cachedStructures)
				{
					// find all typeConstraints (eclass affected!)
					for (AxisConstraint tC : aSn.SearchedConstraints)
					{
						if (tC instanceof TypeConstraint)
						{
							if (((TypeConstraint) tC).getType().equals(clazz))
							{
								// affected typeconstraint's lookvariable should be bound!!
								knownLocalAndParameters.put(((TypeConstraint) tC).getLookvariable(), instance);
							}
						}
					}
				}
				
				
				// the new matches that'll appear in matching
				MultiSet<LookaheadMatching> newbies_todelete = matcher.searchChangesAll(engine, maybeModPattern, cachedStructures, knownLocalAndParameters);
				
				// a new map to store a matching and whether it is added or removed
				HashMultimap<LookaheadMatching, Boolean> newMatchingsAndAddition = HashMultimap.create();//<LookaheadMatching, Boolean>();
				
				// iterate over multiset and create delta
				for (Entry<LookaheadMatching, Integer> inners : newbies_todelete.getInnerMap().entrySet())
				{
					for (int pi = 0; pi < inners.getValue(); pi++)
						newMatchingsAndAddition.put(inners.getKey(), false); // the count in multiset (more of tha same found: more changes), false: deleted!!
				}
				// delta needed to propagate the changes
				Delta d = new Delta(maybeModPattern, newMatchingsAndAddition);
				deltas.add(d);
				
				
				/* ArrayList<AheadStructure> newStructs = createNewFromOldTypeC(true, clazz, instance, GodSetStructures.get(maybeMod)); if (isModified) { MultiSet<LookaheadMatching> toDeletes = matcher.updateAll(engine, maybeMod,
				 * newStructs); HashMap<LookaheadMatching, Boolean> newMap = new HashMap<LookaheadMatching, Boolean>(); if (toDeletes.size()>0) { MultiSet<LookaheadMatching> combinedMatching = GodSet.get(maybeMod); for
				 * (Entry<LookaheadMatching, Integer> inners : toDeletes.getInnerMap().entrySet()) { boolean removed_e = combinedMatching.remove(inners.getKey()); if (removed_e == false) {
				 * System.out.println("Nagy a baj, removed de nem volt benne! Exception!"); } for(int pi=0;pi<inners.getValue();pi++) newMap.put(inners.getKey(), false); // false: deleted matching } GodSet.put(maybeMod, combinedMatching);
				 * Delta d = new Delta(maybeMod, newMap); deltas.add(d); } } else { System.out.println("It is not affected!"); } */
			}
			
			// apply deltas (depth apply!)
			for (Delta delta : deltas)
			{
				DeltaProcessor.getInstance().ProcessDelta(delta);
			}
			
			System.out.println("[ECLASS] Delete affected patterns' matchings ended! Time:" + Long.toString(System.currentTimeMillis() - start));
		}
	};
	
	private boolean isModified;
	// modifies the aheadstructures according to eclass change - matches the constraint by hand (found, not searched, matchingvariables put)
	private ArrayList<AheadStructure> createNewFromOldTypeC(boolean isEClass, EClassifier clazzortype, Object instance, ArrayList<AheadStructure> gotStructs)
	{
		ArrayList<AheadStructure> newStructs = new ArrayList<AheadStructure>();
		for (AheadStructure aSn : gotStructs)
		{
			AheadStructure newaSn = aSn.clone();
			for (AxisConstraint tC : newaSn.SearchedConstraints)
			{
				if (tC instanceof TypeConstraint)
				{
					if (((TypeConstraint) tC).getType().equals(clazzortype))
					{
						// this aheadStructure's typeconstraint's type is affected, match it by hand!
						newaSn.MatchingVariables.put(((TypeConstraint) tC).getLookvariable(), instance);
						newaSn.FoundConstraints.add(tC);
						newaSn.SearchedConstraints.remove(tC);
						isModified = true;
						break;
					}
				}
			}
			newStructs.add(newaSn);
		}
		return newStructs;
	}
	
	// listens to datatype changes, works as the instancelistener, but uses relation structure update (matches relations by hand before matching)
	private DataTypeListener dataTypeListener = new DataTypeListener()
	{
		@Override
		public void dataTypeInstanceInserted(EDataType type, Object instance)
		{
			// DatatypeDelta dataInser = new DatatypeDelta(type, instance, true);
			System.out.println("[EDATATYPE] Update affected patterns' matchings started!");
			long start = System.currentTimeMillis();
			
			// changes:
			ArrayList<Delta> deltas = new ArrayList<Delta>();
			
			for (Pattern maybeModPattern : RelativeSet.get(type))
			{
				// this lookvariable should be ---> this object (the matcher will bind it)
				HashMap<LookVariable, Object> knownLocalAndParameters = new HashMap<LookVariable, Object>();
				
				isModified = false;
				ArrayList<AheadStructure> cachedStructures = GodSetStructures.get(maybeModPattern);
				for (AheadStructure aSn : cachedStructures)
				{
					// find all typeConstraints (eclass affected!)
					for (AxisConstraint tC : aSn.SearchedConstraints)
					{
						if (tC instanceof TypeConstraint)
						{
							if (((TypeConstraint) tC).getType().equals(type))
							{
								// affected typeconstraint's lookvariable should be bound!!
								knownLocalAndParameters.put(((TypeConstraint) tC).getLookvariable(), instance);
							}
						}
					}
				}
				
				
				// the new matches that'll appear in matching
				MultiSet<LookaheadMatching> newbies_toadd = matcher.searchChangesAll(engine, maybeModPattern, cachedStructures, knownLocalAndParameters);
				
				// a new map to store a matching and whether it is added or removed
				HashMultimap<LookaheadMatching, Boolean> newMatchingsAndAddition = HashMultimap.create();//<LookaheadMatching, Boolean>();
				
				// iterate over multiset and create delta
				for (Entry<LookaheadMatching, Integer> inners : newbies_toadd.getInnerMap().entrySet())
				{
					for (int pi = 0; pi < inners.getValue(); pi++)
						newMatchingsAndAddition.put(inners.getKey(), true); // the count in multiset (more of tha same found: more changes)
				}
				// delta needed to propagate the changes
				Delta d = new Delta(maybeModPattern, newMatchingsAndAddition);
				deltas.add(d);
				
				
				/* ArrayList<AheadStructure> newStructs = createNewFromOldTypeC(false, type, instance, GodSetStructures.get(maybeModPattern)); if (isModified) { MultiSet<LookaheadMatching> newbies = matcher.updateAll(engine,
				 * maybeModPattern, newStructs); if (newbies.size()>0) { MultiSet<LookaheadMatching> combinedMatching = GodSet.get(maybeModPattern); for (LookaheadMatching lMa : newbies.toArrayList()) { combinedMatching.add(lMa); }
				 * GodSet.put(maybeModPattern, combinedMatching); } } */
			}
			
			for (Delta delta : deltas)
			{
				DeltaProcessor.getInstance().ProcessDelta(delta);
			}
			
			// match based on the new structs!
			System.out.println("[EDATATYPE] Update matchings finished! Time:" + Long.toString(System.currentTimeMillis() - start));
		}
		
		@Override
		public void dataTypeInstanceDeleted(EDataType type, Object instance)
		{
			// changes:
			ArrayList<Delta> deltas = new ArrayList<Delta>();
			
			// DatatypeDelta dataDelete = new DatatypeDelta(type, instance, false);
			System.out.println("[EDATATYPE] Delete affected patterns' matchings if class instance used in them started!");
			long start = System.currentTimeMillis();
			
			for (Pattern maybeModPattern : RelativeSet.get(type))
			{
				HashMap<LookVariable, Object> knownLocalAndParameters = new HashMap<LookVariable, Object>();
				
				isModified = false;
				ArrayList<AheadStructure> cachedStructures = GodSetStructures.get(maybeModPattern);
				for (AheadStructure aSn : cachedStructures)
				{
					// find all typeConstraints (eclass affected!)
					for (AxisConstraint tC : aSn.SearchedConstraints)
					{
						if (tC instanceof TypeConstraint)
						{
							if (((TypeConstraint) tC).getType().equals(type))
							{
								// affected typeconstraint's lookvariable should be bound!!
								knownLocalAndParameters.put(((TypeConstraint) tC).getLookvariable(), instance);
							}
						}
					}
				}
				// the new matches that'll appear in matching
				MultiSet<LookaheadMatching> newbies_todelete = matcher.searchChangesAll(engine, maybeModPattern, cachedStructures, knownLocalAndParameters);
				
				// a new map to store a matching and whether it is added or removed
				HashMultimap<LookaheadMatching, Boolean> newMatchingsAndRemoval = HashMultimap.create(); // <LookaheadMatching, Boolean>();
				
				// iterate over multiset and create delta
				for (Entry<LookaheadMatching, Integer> inners : newbies_todelete.getInnerMap().entrySet())
				{
					for (int pi = 0; pi < inners.getValue(); pi++)
						newMatchingsAndRemoval.put(inners.getKey(), false); // the count in multiset (more of tha same found: more changes), false: deleted!!
				}
				// delta needed to propagate the changes
				Delta d = new Delta(maybeModPattern, newMatchingsAndRemoval);
				deltas.add(d);
				
				
				
				
				/* ArrayList<AheadStructure> newStructs = createNewFromOldTypeC(false, type, instance, GodSetStructures.get(maybeMod)); if (isModified) { MultiSet<LookaheadMatching> toDeletes = matcher.updateAll(engine, maybeMod,
				 * newStructs); if (toDeletes.size()>0) { MultiSet<LookaheadMatching> combinedMatching = GodSet.get(maybeMod); for (LookaheadMatching lMa : toDeletes.toArrayList()) { boolean removed_e = combinedMatching.remove(lMa); if
				 * (removed_e == false) { System.out.println("Nagy a baj, removed de nem volt benne! Exception!"); } } GodSet.put(maybeMod, combinedMatching); } } */
			}
			
			for (Delta delta : deltas)
			{
				DeltaProcessor.getInstance().ProcessDelta(delta);
			}
			
			System.out.println("[EDATATYPE] Delete affected patterns' matchings ended! Time:" + Long.toString(System.currentTimeMillis() - start));
		}
	};
	
	// modifies the aheadstructures according to estructuralfeature change - matches the constraint by hand (found, not searched, matchingvariables put)
	private ArrayList<AheadStructure> createNewFromOldRelaC(EObject host, Object target, EStructuralFeature edge, ArrayList<AheadStructure> gotStructs)
	{
		ArrayList<AheadStructure> newStructs = new ArrayList<AheadStructure>();
		for (AheadStructure aSn : gotStructs)
		{
			AheadStructure newaSn = aSn.clone();
			for (AxisConstraint rC : newaSn.SearchedConstraints)
			{
				if (rC instanceof RelationConstraint)
				{
					if (((RelationConstraint) rC).getEdge().equals(edge))
					{
						// satisfy relation source and target
						newaSn.MatchingVariables.put(((RelationConstraint) rC).getSource(), host);
						newaSn.MatchingVariables.put(((RelationConstraint) rC).getTarget(), target);
						// and make constraint "found"
						newaSn.FoundConstraints.add(rC);
						newaSn.SearchedConstraints.remove(rC);
						isModified = true;
						break;
					}
				}
			}
			newStructs.add(newaSn);
		}
		return newStructs;
	}
	
	// listens to structuralfeature changes, uses relation modification, others are like instancelistener)
	private FeatureListener featureListener = new FeatureListener()
	{
		@Override
		public void featureInserted(EObject host, EStructuralFeature feature, Object value)
		{
			// Delta featureInser = new FeatureDelta(feature, host, true, value);
			System.out.println("[ESTRUCTURALFEATURE] Update affected patterns' matchings started!");
			long start = System.currentTimeMillis();
			// changes:
			ArrayList<Delta> deltas = new ArrayList<Delta>();
			
			for (Pattern maybeModPattern : RelativeSet.get(feature))
			{
				// this lookvariable should be ---> this object (the matcher will bind it)
				HashMap<LookVariable, Object> knownLocalAndParameters = new HashMap<LookVariable, Object>();
				
				isModified = false;
				ArrayList<AheadStructure> cachedStructures = GodSetStructures.get(maybeModPattern);
				for (AheadStructure aSn : cachedStructures)
				{
					// find all relationConstraints
					for (AxisConstraint rC : aSn.SearchedConstraints)
					{
						if (rC instanceof RelationConstraint)
						{
							if (((RelationConstraint) rC).getEdge().equals(feature))
							{
								// affected relaconstraint's lookvariables should be bound!!
								knownLocalAndParameters.put(((RelationConstraint) rC).getSource(), host);
								knownLocalAndParameters.put(((RelationConstraint) rC).getTarget(), value);
							}
						}
					}
				}
				
				
				// the new matches that'll appear in matching
				MultiSet<LookaheadMatching> newbies_toadd = matcher.searchChangesAll(engine, maybeModPattern, cachedStructures, knownLocalAndParameters);
				
				// a new map to store a matching and whether it is added or removed
				HashMultimap<LookaheadMatching, Boolean> newMatchingsAndAddition = HashMultimap.create(); // <LookaheadMatching, Boolean>();
				
				// iterate over multiset and create delta
				for (Entry<LookaheadMatching, Integer> inners : newbies_toadd.getInnerMap().entrySet())
				{
					for (int pi = 0; pi < inners.getValue(); pi++)
						newMatchingsAndAddition.put(inners.getKey(), true); // the count in multiset (more of tha same found: more changes)
				}
				// delta needed to propagate the changes
				Delta d = new Delta(maybeModPattern, newMatchingsAndAddition);
				deltas.add(d);
			}
			// apply deltas
			for (Delta delta : deltas)
			{
				DeltaProcessor.getInstance().ProcessDelta(delta);
			}
			
			System.out.println("[ESTRUCTURALFEATURE] Update matchings finished! Time:" + Long.toString(System.currentTimeMillis() - start));
		}
		
		@Override
		public void featureDeleted(EObject host, EStructuralFeature feature, Object value)
		{
			// Delta featureDeleted = new FeatureDelta(feature, host, false, value);
			System.out.println("[ESTRUCTURALFEATURE] Delete affected patterns' matchings if class instance used in them started!");
			long start = System.currentTimeMillis();
			
			// changes:
			ArrayList<Delta> deltas = new ArrayList<Delta>();
			
			for (Pattern maybeModPattern : RelativeSet.get(feature))
			{
				// this lookvariable should be ---> this object (the matcher will bind it)
				HashMap<LookVariable, Object> knownLocalAndParameters = new HashMap<LookVariable, Object>();
				
				isModified = false;
				ArrayList<AheadStructure> cachedStructures = GodSetStructures.get(maybeModPattern);
				for (AheadStructure aSn : cachedStructures)
				{
					// find all relationConstraints
					for (AxisConstraint rC : aSn.SearchedConstraints)
					{
						if (rC instanceof RelationConstraint)
						{
							if (((RelationConstraint) rC).getEdge().equals(feature))
							{
								// affected relaconstraint's lookvariables should be bound!!
								knownLocalAndParameters.put(((RelationConstraint) rC).getSource(), host);
								knownLocalAndParameters.put(((RelationConstraint) rC).getTarget(), value);
							}
						}
					}
				}
				
				
				// the new matches that'll appear in matching
				MultiSet<LookaheadMatching> newbies_toremove = matcher.searchChangesAll(engine, maybeModPattern, cachedStructures, knownLocalAndParameters);
				
				// a new map to store a matching and whether it is added or removed
				HashMultimap<LookaheadMatching, Boolean> newMatchingsAndRemoval = HashMultimap.create(); // <LookaheadMatching, Boolean>();
				
				// iterate over multiset and create delta
				for (Entry<LookaheadMatching, Integer> inners : newbies_toremove.getInnerMap().entrySet())
				{
					for (int pi = 0; pi < inners.getValue(); pi++)
						newMatchingsAndRemoval.put(inners.getKey(), false); // the count in multiset (more of tha same found: more changes)
				}
				// delta needed to propagate the changes
				Delta d = new Delta(maybeModPattern, newMatchingsAndRemoval);
				deltas.add(d);
				
				/* isModified = false; ArrayList<AheadStructure> newStructs = createNewFromOldRelaC(host, value, feature, GodSetStructures.get(maybeModPattern)); if (isModified) { MultiSet<LookaheadMatching> toDeletes =
				 * matcher.updateAll(engine, maybeModPattern, newStructs); if (toDeletes.size()>0) { MultiSet<LookaheadMatching> combinedMatching = GodSet.get(maybeModPattern); for (LookaheadMatching lMa : toDeletes.toArrayList()) {
				 * boolean
				 * removed_e = combinedMatching.remove(lMa); if (removed_e == false) { System.out.println("Nagy a baj, removed de nem volt benne! Exception!"); } } GodSet.put(maybeModPattern, combinedMatching); } } */
			}
			// apply deltas
			for (Delta delta : deltas)
			{
				DeltaProcessor.getInstance().ProcessDelta(delta);
			}
			
			System.out.println("[ESTRUCTURALFEATURE] Delete affected patterns' matchings ended! Time:" + Long.toString(System.currentTimeMillis() - start));
			
		}
	};
	
	// matches a pattern and creates and saves listeners to the pattern's instances/datatypes/structuralfeatures
	public boolean registerPatternWithMatches(Pattern pattern)
	{
		// match!
		MultiSet<LookaheadMatching> matches = matcher.matchAll(engine, pattern, null);
		
		// put pattern matches to registry
		GodSet.put(pattern, matches);
		// put structures to registry (if modified, fast matching available)
		GodSetStructures.put(pattern, matcher.GetAheadStructures());
		
		// register new types!
		ArrayList<ENamedElement> nameds = new ArrayList<ENamedElement>();
		for (TypeConstraint tCon : matcher.GetTypeConstraints())
		{
			// register if class and register if not already registered type
			if (!nameds.contains(tCon.getType()))
				nameds.add(tCon.getType());
		}
		ArrayList<EDataType> types = new ArrayList<EDataType>();
		ArrayList<EClass> classes = new ArrayList<EClass>();
		for (ENamedElement eNamed : nameds)
		{
			if (eNamed instanceof EDataType)
				types.add((EDataType) eNamed);
			else if (eNamed instanceof EClass)
				classes.add((EClass) eNamed);
		}
		
		// register new relations!
		ArrayList<EStructuralFeature> featureds = new ArrayList<EStructuralFeature>();
		for (RelationConstraint rCon : matcher.GetRelationConstraints())
		{
			// register if class and register if not already registered type
			if (!featureds.contains(rCon.getEdge()))
				featureds.add(rCon.getEdge());
			// egysegesen
			if (!nameds.contains(rCon.getEdge()))
				nameds.add(rCon.getEdge());
		}
		ArrayList<EStructuralFeature> features = new ArrayList<EStructuralFeature>();
		for (EStructuralFeature eFeatured : featureds)
		{
			features.add(eFeatured);
		}
		
		if (types.size() > 0)
			navHelp.registerDataTypeListener(types, dataTypeListener);
		if (classes.size() > 0)
			navHelp.registerInstanceListener(classes, classListener);
		if (features.size() > 0)
			navHelp.registerFeatureListener(features, featureListener);
		
		// fill relativeSet!
		for (ENamedElement eNamed : nameds)
		{
			if (RelativeSet.containsKey(eNamed))
			{
				// add to already existing list
				HashSet<Pattern> pats = RelativeSet.get(eNamed);
				if (!pats.contains(eNamed))
					pats.add(pattern);
				RelativeSet.put(eNamed, pats);
			}
			else
			{
				// add as first (never will be null)
				HashSet<Pattern> newPatInSet = new HashSet<Pattern>();
				newPatInSet.add(pattern);
				RelativeSet.put(eNamed, newPatInSet);
			}
		}
		
		// find/negfind patterns (whole tree) of the pattern
		
		FillPatternCallsPatterns(pattern);
		
		
		return true;
	}
	// find recursively
	private void FillPatternCallsPatterns(Pattern actRoot)
	{
		// find children of this root
		HashMap<Pattern, Boolean> findedNegfindedPatterns = matcher.getFindListForPattern(actRoot);
		if (findedNegfindedPatterns != null && findedNegfindedPatterns.size() > 0)
			PatternCallsPatterns.put(actRoot, findedNegfindedPatterns);
		else return; // no more children
		for (Entry<Pattern, Boolean> finded : findedNegfindedPatterns.entrySet())
		{
			// iterate for children and find their calls, too
			FillPatternCallsPatterns(finded.getKey());
		}
	}
	
	// matches a pattern using TREAT caching or creates a ner cache if pattern is previously not cached
	public MultiSet<LookaheadMatching> matchThePattern(Pattern pattern)
	{
		// null: does not contain, not null: contains, maybe empty
		if (GodSet.get(pattern) != null)
			return GodSet.get(pattern);
		this.registerPatternWithMatches(pattern);
		if (GodSet.get(pattern) != null)
		{
			return GodSet.get(pattern);
		}
		else
		{
			System.err.println("Fatal error: matcher ran successfully, but something failed during caching.");
			return null; // error
		}
	}
}
