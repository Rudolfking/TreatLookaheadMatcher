package hu.bme.mit.inf.lookaheadmatcher.impl;

import hu.bme.mit.inf.lookaheadmatcher.LookaheadMatcherInterface;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

import org.eclipse.emf.common.util.EList;
import org.eclipse.viatra2.emf.incquery.runtime.api.IPatternMatch;
import org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryEngine;
import org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryMatcher;
import org.eclipse.viatra2.emf.incquery.runtime.exception.IncQueryException;
import org.eclipse.viatra2.emf.incquery.runtime.extensibility.MatcherFactoryRegistry;
import org.eclipse.viatra2.gtasm.patternmatcher.incremental.rete.construction.RetePatternBuildException;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.IntValue;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.LiteralValueReference;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.ParameterRef;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.Pattern;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.PatternCall;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.StringValue;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.ValueReference;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.Variable;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.VariableValue;

public class NACConstraint extends CheckableConstraint implements IConstraint
{
	private ArrayList<LookVariable> affectedVariables;
	private PatternCall nacPatternCall;
	private IncQueryEngine engineRef;
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public boolean Evaluate(HashMap<LookVariable, Object> MatchingVariables)
	{
		if (!CanBeEvaluated(MatchingVariables))
			return false; // heh?
		
		Pattern nacPattern = nacPatternCall.getPatternRef();

		//CorePatternLanguageHelper.
		
		// vanemár
		// engineRef.getSanitizer().getAdmittedPatterns();
		
		// use own code
		// if can be matched, then return false, if cannot, return true (NAC)
		//public LookaheadMatching[] matchAll(IncQueryEngine engine, Pattern pattern, ArrayList<Object> knownValues)
		ArrayList<Object> knownValues = new ArrayList<Object>();
		
		EList<ValueReference> parameters = this.nacPatternCall.getParameters();
		for(int i=0;i<parameters.size();i++)
		{
			ValueReference valRef = parameters.get(i);
			Variable var = null;
			Object knownIfNotVar = null;
			if (valRef instanceof VariableValue)
			{
				VariableValue varvalref = (VariableValue)valRef;
				if (varvalref.getValue().getVariable() instanceof ParameterRef)
					var = ((ParameterRef)varvalref.getValue().getVariable()).getReferredParam();
				else
					var = ((VariableValue)valRef).getValue().getVariable();
			}
			else if (valRef instanceof LiteralValueReference)
			{
				LiteralValueReference lvr = (LiteralValueReference)valRef;
				if (lvr instanceof IntValue)
				{
					knownIfNotVar = ((IntValue)lvr).getValue();
				}
				else if (lvr instanceof StringValue)
				{
					knownIfNotVar = ((StringValue)lvr).getValue();
				}
				// var==null   STAYS!!
			}
			LookVariable thisvar = null;
			for(LookVariable v : this.affectedVariables)
			{
				if (v.getVariable() == null && var == null)
				{
					// literal alca variable
					break;
				}
				else if (v.getVariable().equals(var))
				{
					thisvar = v;
					break;
				}
			}
			if (var == null)
			{
				knownValues.add(knownIfNotVar); // it is a running variable (futo valtozo, na)
			}
			else if (var.getName().startsWith("_"))
			{
				knownValues.add(null); // it is a running variable (futo valtozo, na)
				// run! https://www.youtube.com/watch?v=sgxVPwTW-1E
			}
			else if (thisvar != null)
				knownValues.add(MatchingVariables.get(thisvar));
			else // thisvar == null
			{
				System.out.println("Szar van");
			}
		}
		
		boolean[] mask = new boolean[knownValues.size()];
		for (int i = 0; i < mask.length; i++) {
			mask[i] = knownValues.get(i)==null?false:true;
		}

		// direct Rete call
		
		try {
			Object reti = engineRef.getReteEngine().accessMatcher(nacPattern).matchOne(knownValues.toArray(), mask);
			if (reti!=null)
			{
				System.out.println("RETE from native call NAC call returned: "+reti.toString());
				return false;
			}
			return true;
		} catch (RetePatternBuildException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IncQueryException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// IQ interface call
		try {
			IncQueryMatcher matcher = null;
			boolean hasMatch = true;
			matcher = MatcherFactoryRegistry.getOrCreateMatcherFactory(nacPattern).getMatcher(engineRef);
			IPatternMatch partialMatch = matcher.newMatch(knownValues.toArray());
			hasMatch = matcher.hasMatch(partialMatch);
			System.out.println("RETE from interface NAC call returned: "+Boolean.toString(!hasMatch));
			if (hasMatch)
				return false;
			return true;
		} catch (IncQueryException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// bukta eseten sajat kod

		LookaheadMatcherInterface lmi = new LookaheadMatcherInterface();
		boolean tried = lmi.tryMatch(engineRef, nacPattern, knownValues);
		System.out.println("My (Lookahead Pattern Matches) NAC call returned: "+Boolean.toString(!tried));
		if (tried)
			return false; // can be matched, this is bad
		return true;
	}

	@Override
	public boolean CanBeEvaluated(
			HashMap<LookVariable, Object> MatchingVariables)
	{
		for(LookVariable v : this.affectedVariables)
		{
			if (MatchingVariables.get(v)==null)
			{
				if (v.getVariable().getName().startsWith("_") == false)
					return false;
				// else v is a running variable
			}
		}
		return true; // canna be
	}

	@Override
	public String toString()
	{
		return this.nacPatternCall.getPatternRef().getName()+"("+writeArray(this.affectedVariables)+")";
	}
	
	private String writeArray(ArrayList<LookVariable> vv)
	{
		String ret="";
		for(LookVariable v:vv)
		{
			ret+=v.getVariableName()+",";
		}
		ret = ret.substring(0, ret.length()-1);
		return ret;
	}
	
	
	@SuppressWarnings("unused")
	private NACConstraint(){}
	
	public NACConstraint(Collection<LookVariable> affected, PatternCall NACPatternCall, IncQueryEngine engine)
	{
		this.affectedVariables = new ArrayList<LookVariable>();
		this.affectedVariables.addAll(affected);
		this.nacPatternCall = NACPatternCall;
		this.engineRef = engine;
	}
}
