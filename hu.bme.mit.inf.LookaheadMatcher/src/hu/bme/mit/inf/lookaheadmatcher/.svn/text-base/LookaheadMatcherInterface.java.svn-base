package hu.bme.mit.inf.lookaheadmatcher;

import hu.bme.mit.inf.lookaheadmatcher.impl.AheadStructure;
import hu.bme.mit.inf.lookaheadmatcher.impl.AxisConstraint;
import hu.bme.mit.inf.lookaheadmatcher.impl.LookVariable;
import hu.bme.mit.inf.lookaheadmatcher.impl.LookaheadMatching;
import hu.bme.mit.inf.lookaheadmatcher.impl.MatcherAlgorithm;
import hu.bme.mit.inf.lookaheadmatcher.impl.MultiSet;
import hu.bme.mit.inf.lookaheadmatcher.impl.PatternProcessor;
import hu.bme.mit.inf.lookaheadmatcher.impl.RelationConstraint;
import hu.bme.mit.inf.lookaheadmatcher.impl.TypeConstraint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

import org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryEngine;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.Constraint;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.Pattern;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.PatternBody;
import org.eclipse.viatra2.patternlanguage.core.patternLanguage.PatternCompositionConstraint;
import org.eclipse.viatra2.emf.incquery.base.api.NavigationHelper;
import org.eclipse.viatra2.emf.incquery.runtime.exception.IncQueryException;

//import org.eclipse.viatra2.emf.incquery.base.exception.IncQueryBaseException;

public class LookaheadMatcherInterface
{
	public LookaheadMatcherInterface()
	{
		super();
	}
	
	private NavigationHelper navigationHelper;
	
	public boolean tryMatch(IncQueryEngine engine, Pattern pattern, ArrayList<Object> knownValues)
	{
		try
		{
			this.navigationHelper = engine.getBaseIndex();
		}
		catch (IncQueryException e)
		{
			e.printStackTrace();
			return false;
		}
		PatternProcessor pProc = new PatternProcessor(engine);
		ArrayList<AheadStructure> matchingStates = pProc.Process(pattern);
		
		MultiSet<LookaheadMatching> matches = new MultiSet<LookaheadMatching>();
		
		for (AheadStructure state : matchingStates)
		{
			matches.addAll(new MatcherAlgorithm().getPatternMatches(state, true, navigationHelper, knownValues));
		}
		
		if (matches.size() > 0)
			return true; // matched on one of the branches
		return false; // no matches
	}
	
	private ArrayList<TypeConstraint> typeConstraints = new ArrayList<TypeConstraint>();
	private ArrayList<RelationConstraint> relationConstraints = new ArrayList<RelationConstraint>();
	private ArrayList<AheadStructure> aheadStructures = new ArrayList<AheadStructure>();
	
	public ArrayList<TypeConstraint> GetTypeConstraints()
	{
		return this.typeConstraints;
	}
	public ArrayList<RelationConstraint> GetRelationConstraints()
	{
		return this.relationConstraints;
	}
	public ArrayList<AheadStructure> GetAheadStructures()
	{
		return this.aheadStructures;
	}
	
	// this is the regular matching method: processes a pattern, then matches
	@SuppressWarnings("unchecked")
	public MultiSet<LookaheadMatching> matchAll(IncQueryEngine engine, Pattern pattern, ArrayList<Object> knownValues)
	{
		// get navhelper
		try
		{
			this.navigationHelper = engine.getBaseIndex();
		}
		catch (IncQueryException e)
		{
			e.printStackTrace();
			return null;
		}
		
		// process pattern
		ArrayList<AheadStructure> matchingStates = processPattern(pattern, engine);
		this.aheadStructures = (ArrayList<AheadStructure>) matchingStates.clone(); // clone to cache
		
		
		// return with matches (knownvalues when matching, known_even_locals is that we don't have in this case)
		MultiSet<LookaheadMatching> rett = matchWithProcessed(matchingStates, knownValues, null);
		System.out.println("Match finished for pattern " + pattern.getName());
		return rett;
		/*LookaheadMatching[] ret = new LookaheadMatching[matches.size()];
		int hol = 0;
		for (LookaheadMatching lookaheadMatching : matches) {
			ret[hol++] = lookaheadMatching;
		}
		return ret;*/
	}
	
	// process pattern
	private ArrayList<AheadStructure> processPattern(Pattern pattern, IncQueryEngine engine)
	{
		return (new PatternProcessor(engine)).Process(pattern);
	}
	
	// process pattern ready, pass to match
	// two options are available: knownValues (in order of pattern definition variables) are known values of the parameter variables
	//      the other option is knownLocalAndParameters (can be any variable present in this pattern) to bind those vars
	private MultiSet<LookaheadMatching> matchWithProcessed(ArrayList<AheadStructure> preparedStructures, ArrayList<Object> knownValues, HashMap<LookVariable, Object> knownLocalAndParameters)
	{
		// create matcher algo
		MatcherAlgorithm readyToMatchAlgo = new MatcherAlgorithm();
		
		//matches to return
		MultiSet<LookaheadMatching> matches = new MultiSet<LookaheadMatching>();
		
		// iterate all structure and match them! (collect matches)
		for (AheadStructure state : preparedStructures)
		{
			// cache constraints (empty then add)
			this.typeConstraints.clear();
			this.relationConstraints.clear();
			for (AxisConstraint conss : state.SearchedConstraints)
			{
				if (conss instanceof TypeConstraint)
					this.typeConstraints.add((TypeConstraint) conss);
				else if (conss instanceof RelationConstraint)
					this.relationConstraints.add((RelationConstraint) conss);
			}
			
			// insert locals into the game
			if (knownLocalAndParameters != null)
			{
				for (Entry<LookVariable, Object> knownOne : knownLocalAndParameters.entrySet())
				{
					if (state.MatchingVariables.containsKey(knownOne.getKey()) == false)
					{
						System.err.println("Fucking big error, baaad");
					}
					readyToMatchAlgo.bindToVariable(knownOne.getKey(), knownOne.getValue(), state.MatchingVariables);
				}
			}
			// known any kind of var's values are bound, but
			// known values are bound in getPatternMatches(,,,)!!!!!!! - if not null
			matches.addAll(readyToMatchAlgo.getPatternMatches(state, false, navigationHelper, knownValues));
		}
		
		// write out!
		int laza = 0;
		for (LookaheadMatching oneMatch : matches.toArrayList())
		{
			System.out.println("Match " + Integer.toString(laza) + ":" + oneMatch.toString());
			laza++;
		}
		System.out.println("Total matches from all body: " + matches.size());
		
		return matches;
	}
	
	public MultiSet<LookaheadMatching> searchChangesAll(IncQueryEngine engine, Pattern modPattern, AheadStructure cachedStructure, HashMap<LookVariable, Object> knownValues)
	{
		ArrayList<AheadStructure> structOne = new ArrayList<AheadStructure>();
		structOne.add(cachedStructure);
		return this.searchChangesAll(engine, modPattern, structOne, knownValues);
	}
	
	public MultiSet<LookaheadMatching> searchChangesAll(IncQueryEngine engine, Pattern modPattern, ArrayList<AheadStructure> cachedStructures, HashMap<LookVariable, Object> knownValues)
	{
		try
		{
			this.navigationHelper = engine.getBaseIndex();
		}
		catch (IncQueryException e)
		{
			e.printStackTrace();
			return null;
		}
		
		MultiSet<LookaheadMatching> matches = new MultiSet<LookaheadMatching>();
		
		// for all cached structures
		//for(AheadStructure state : cachedStructures)
		//{
		//	matches.addAll(new MatcherAlgorithm().getPatternMatches(state, false, navigationHelper,null));
		//}
		
		// match all with no known values but known mapped values to bind (can be local etc.)
		matches.addAll(matchWithProcessed(cachedStructures, null, knownValues));
		
		System.out.println("[Update] Find new matches for pattern " + modPattern.getName() + " (all bodies): " + matches.size());
		
		return matches;
	}
	
	// returns all findX negfindX patterns, that occur in P
	public HashMap<Pattern, Boolean> getFindListForPattern(Pattern P)
	{
		HashMap<Pattern, Boolean> find_negfind_patterns = new HashMap<Pattern, Boolean>();
		for (PatternBody body : P.getBodies())
		{
			for (Constraint calls : body.getConstraints())
			{
				if (calls instanceof PatternCompositionConstraint)
				{
					// remember for the patterncompositionconstraint's call's pattern reference (thid pattern is called and is in a constraint)
					Pattern findthisPattern = ((PatternCompositionConstraint) calls).getCall().getPatternRef();
					Boolean isPositiveCall = ((PatternCompositionConstraint) calls).isNegative() == true ? Boolean.FALSE : Boolean.TRUE;
					// add this pattern
					find_negfind_patterns.put(findthisPattern, isPositiveCall);
					// and this pattern's find/negfind patterns
					//find_negfind_patterns.addAll(getFindHierarchyForPattern(findthisPattern));
				}
			}
		}
		
		return find_negfind_patterns;
	}
}
